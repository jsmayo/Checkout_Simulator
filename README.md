# ShoppingSimulator Design Proposal

Shopping simuation program designed as part of a course project.

*Initial creation: February 10, 2017*

1. Initial Design UML: [Initial design](/InitialDesignProposal.png)
2. Final Design UML: [Final design](https://github.com/jsmayo/ShoppingSimulator/blob/master/FinalUMLDesign.png)

## 1.	DESIGN OVERVIEW

To fully implement the requested behavior of the client, a design proposal of eight classes has been put forth and can be seen [here](ShoppingSimulator/InitialDesignProposal.png).  The swing components and other behaviors relating to the user interface will be contained in the EKIAShoppingSimulatorGUI class. Although the user will be interacting with this class for user input, the program’s core logic will primarily be housed in the EKIAShoppingSimulator class, itself. The EKIAShoppingSimulator class will use instances of the Regular, Express, and Special Cart classes. These classes define core behavior that is inherited from the abstract Cart class. An abstract class is being proposed, since all three Cart objects share similar functionality, as well as have minor differences in overall attribute and class behavior. Additionally, a Register class is being proposed to not only simplify program design, but to simplify the data tracking as well. As such, variables and calculations that are primarily associated with the register section/checkout process are housed in the Register class. Furthermore, as seen in the [UML design](ShoppingSimulator/InitialDesignProposal.png), the Register class requires an implementation of an EventCalendar interface. This interface will ultimately allow the Register class to mark when a Cart starts and finishes the checkout process, which will then be used to update the EKIAShoppingSimuator class, and finally be displayed by the EKIAShoppingSimulatorGUI class. 
  
## 2.	CONTROL FLOW OVERVIEW

The initial flow of control begins at the EKIAShoppingSimulator class, where the main() function is called to produce an instance of the class itself, as well as, create an instance of the EKIAShoppingSimulatorGUI class to allow for user input. When the GUI is started, valid parameter input will be required to simulate a shopping experience. These variables will need to be input into the appropriate swing components, which will later be checked for validity against client specifications. If the arguments are valid, the EKIAShoppingSimulator class will attempt to create the requested number of Cart and Register objects by calling the Register and Cart (Regular, Express, and Special) class constructors. Once created, the Carts and Register objects will simulate a shopping experience by shopping for a semi-randomly, predetermined amount of time, and then attempt to checkout once that time has elapsed. 

The calculations for the Cart class are built into the abstract Cart classes’ inner logic, which is inherited by each of the three types of carts. For example, the methods calcArrivalTime()and  calcWaitTime() are critical in determining how long the Cart spends shopping and how long it will ultimately wait in line. The Cart’s decision making logic for which line it decides to populate, is based on client specifications, which are tailored to the Cart’s respective type. So, since each type was requested to exhibit different queue making decisions, the chooseRegister() method was designed to be stated in the abstract Cart class, but ultimately defined by the inheriting class. 
 
 To keep track of Events and help regulate when the program should log its data, update the GUI, modify the Register’s checkout line, start and stop the simulation, etc.…  required a custom-tailored, event-tracking-interface. As seen in the [UML design](ShoppingSimulator/InitialDesignProposal.png), it is proposed that the CalendarEvent interface be implemented by the Register class. The Register class was chosen as the container class, since overall checkout functionality needed to be both contained, as well as, streamlined across every active instance of Register. This decision may change as the project advances, but at the time, the Register class appeared the most logical choice. However, as it stands, there are two sources for events to trigger the CalendarEvent interface. The first is when a Cart enters a register line, which triggers the createEvent() method. The second event trigger occurs when a Cart completes the checkout process, which in turn calls the updateEvent() and updateProgress() methods of the CalendarEvent interface. Data collected during these methods execution will be used by the EKIAShoppingSimulator class and the EkiaShoppingSimulatorGUI class to display the average wait time, display the average checkout time, and update the simulation progress as each checkout is completed. 
 
## 3.	LIMITATIONS & CONTRAINTS

There are limitations with the proposed design, as well as, several constraints placed upon the system. However, these limitations and constraints are present and/or implemented to simulate a shopping experience that strictly adheres to the requirements requested by the client.

The fist limitation of the design is the strict use of integer values for logging all time-related variables. The use of integers for data tracking introduces a minor loss in precision when it comes to reporting wait and checkout times. However, the loss in precision was determined to be negligible when it comes to analyzing data over the lifetime of the program. Additionally, the formatting can be considered a limitation as well, since all variables relating to time are generated as an integer value. However, if desired, the formatting can easily be altered without any loss in functionality.

The second limitation is the inability to completely design a program that models every possible scenario that can influence a Carts’ average combined checkout and wait time. However, constraints were placed upon both the Cart and Register class instances to help simulate a real-world shopping experience. For example, constraints are placed upon the minimum and maximum checkout time for each respective Cart type. These values allow the program to run without simulating unrealistic checkout times that otherwise would have been simulated, since the Cart’s initial checkout time is calculated and assigned upon creation.  
	
Additionally, the instantiation of each Carts’ type is further constrained by creation factors that are used to model a real world shopping experience, which have been omitted from this online publication. These factors are an attempt to model the number of Regular, Express, and Special Cart types that the store should expect to handle on a normal basis. Creation factors were also used to constrain the number of Register types and have also been omitted from this online publication. These values were implemented with the same reasoning as those selected for the Cart class - to model a real-world shopping simulation. It should be noted that the creation factors were provided by the client, as was constraining the total number of instantiated Register objects to exist within the bounds of 3-12, inclusive. 

